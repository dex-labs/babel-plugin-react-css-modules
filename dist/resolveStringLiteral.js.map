{"version":3,"file":"resolveStringLiteral.js","names":["_core","require","_types","_conditionalClassMerge","_interopRequireDefault","_getClassName","e","__esModule","default","_default","path","styleModuleImportMap","sourceAttribute","destinationName","options","resolvedStyleName","getClassName","value","destinationAttribute","node","openingElement","attributes","find","attribute","name","isStringLiteral","isJSXExpressionContainer","expression","conditionalClassMerge","stringLiteral","Error","splice","indexOf","exports"],"sources":["../src/resolveStringLiteral.js"],"sourcesContent":["// @flow\n\nimport { NodePath } from '@babel/core';\n\nimport {\n  isJSXExpressionContainer,\n  isStringLiteral,\n  JSXAttribute,\n  stringLiteral,\n} from '@babel/types';\nimport conditionalClassMerge from './conditionalClassMerge';\nimport getClassName from './getClassName';\nimport type {\n  StyleModuleImportMapType,\n  GetClassNameOptionsType,\n} from './types';\n\n/**\n * Updates the className value of a JSX element using a provided\n * styleName attribute.\n */\nexport default (\n  path: typeof NodePath,\n  styleModuleImportMap: StyleModuleImportMapType,\n  sourceAttribute: typeof JSXAttribute,\n  destinationName: string,\n  options: GetClassNameOptionsType,\n): void => {\n  const resolvedStyleName = getClassName(\n    sourceAttribute.value.value,\n    styleModuleImportMap,\n    options,\n  );\n\n  const destinationAttribute = path.node.openingElement.attributes\n    .find((attribute) => typeof attribute.name !== 'undefined' && attribute.name.name === destinationName);\n\n  if (destinationAttribute) {\n    if (isStringLiteral(destinationAttribute.value)) {\n      destinationAttribute.value.value += ` ${resolvedStyleName}`;\n    } else if (isJSXExpressionContainer(destinationAttribute.value)) {\n      destinationAttribute.value.expression = conditionalClassMerge(\n        destinationAttribute.value.expression,\n        stringLiteral(resolvedStyleName),\n      );\n    } else {\n      throw new Error(`Unexpected attribute value:${destinationAttribute.value}`);\n    }\n\n    path.node.openingElement.attributes.splice(\n      path.node.openingElement.attributes.indexOf(sourceAttribute),\n      1,\n    );\n  } else {\n    /* eslint-disable no-param-reassign */\n    sourceAttribute.name.name = destinationName;\n    sourceAttribute.value.value = resolvedStyleName;\n    /* eslint-enable no-param-reassign */\n  }\n};\n"],"mappings":";;;;;;AAEA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,MAAA,GAAAD,OAAA;AAMA,IAAAE,sBAAA,GAAAC,sBAAA,CAAAH,OAAA;AACA,IAAAI,aAAA,GAAAD,sBAAA,CAAAH,OAAA;AAA0C,SAAAG,uBAAAE,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAM1C;AACA;AACA;AACA;AAHA,IAAAG,QAAA,GAIeA,CACbC,IAAqB,EACrBC,oBAA8C,EAC9CC,eAAoC,EACpCC,eAAuB,EACvBC,OAAgC,KACvB;EACT,MAAMC,iBAAiB,GAAG,IAAAC,qBAAY,EACpCJ,eAAe,CAACK,KAAK,CAACA,KAAK,EAC3BN,oBAAoB,EACpBG,OACF,CAAC;EAED,MAAMI,oBAAoB,GAAGR,IAAI,CAACS,IAAI,CAACC,cAAc,CAACC,UAAU,CAC7DC,IAAI,CAAEC,SAAS,IAAK,OAAOA,SAAS,CAACC,IAAI,KAAK,WAAW,IAAID,SAAS,CAACC,IAAI,CAACA,IAAI,KAAKX,eAAe,CAAC;EAExG,IAAIK,oBAAoB,EAAE;IACxB,IAAI,IAAAO,sBAAe,EAACP,oBAAoB,CAACD,KAAK,CAAC,EAAE;MAC/CC,oBAAoB,CAACD,KAAK,CAACA,KAAK,IAAI,IAAIF,iBAAiB,EAAE;IAC7D,CAAC,MAAM,IAAI,IAAAW,+BAAwB,EAACR,oBAAoB,CAACD,KAAK,CAAC,EAAE;MAC/DC,oBAAoB,CAACD,KAAK,CAACU,UAAU,GAAG,IAAAC,8BAAqB,EAC3DV,oBAAoB,CAACD,KAAK,CAACU,UAAU,EACrC,IAAAE,oBAAa,EAACd,iBAAiB,CACjC,CAAC;IACH,CAAC,MAAM;MACL,MAAM,IAAIe,KAAK,CAAC,8BAA8BZ,oBAAoB,CAACD,KAAK,EAAE,CAAC;IAC7E;IAEAP,IAAI,CAACS,IAAI,CAACC,cAAc,CAACC,UAAU,CAACU,MAAM,CACxCrB,IAAI,CAACS,IAAI,CAACC,cAAc,CAACC,UAAU,CAACW,OAAO,CAACpB,eAAe,CAAC,EAC5D,CACF,CAAC;EACH,CAAC,MAAM;IACL;IACAA,eAAe,CAACY,IAAI,CAACA,IAAI,GAAGX,eAAe;IAC3CD,eAAe,CAACK,KAAK,CAACA,KAAK,GAAGF,iBAAiB;IAC/C;EACF;AACF,CAAC;AAAAkB,OAAA,CAAAzB,OAAA,GAAAC,QAAA","ignoreList":[]}